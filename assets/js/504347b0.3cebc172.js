"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1554],{9049:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"learn-graphql/guides/graphql-execution","title":"GraphQL Execution","description":"How data is retrieved and assembled according to the schema and requests","source":"@site/docs/learn-graphql/guides/graphql-execution.md","sourceDirName":"learn-graphql/guides","slug":"/learn-graphql/guides/graphql-execution","permalink":"/graphitation/docs/learn-graphql/guides/graphql-execution","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/graphitation/tree/main/website/docs/learn-graphql/guides/graphql-execution.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"id":"graphql-execution","title":"GraphQL Execution","description":"How data is retrieved and assembled according to the schema and requests"},"sidebar":"tutorialSidebar","previous":{"title":"The design of GraphQL","permalink":"/graphitation/docs/learn-graphql/guides/the-design-of-graphql"},"next":{"title":"The GraphQL Client","permalink":"/graphitation/docs/learn-graphql/guides/graphql-client"}}');var s=t(4848),r=t(8453);const i={sidebar_position:4,id:"graphql-execution",title:"GraphQL Execution",description:"How data is retrieved and assembled according to the schema and requests"},o="GraphQL Execution",l={},h=[{value:"Get only what you need",id:"get-only-what-you-need",level:2},{value:"Resolution",id:"resolution",level:2},{value:"\ud83d\udc4e Greedy resolution",id:"-greedy-resolution",level:3},{value:"A note on the default field resolver",id:"a-note-on-the-default-field-resolver",level:3},{value:"\ud83d\udc4d Lazy resolution",id:"-lazy-resolution",level:3},{value:"Flexibility for different needs",id:"flexibility-for-different-needs",level:4},{value:"Consistency throughout the schema",id:"consistency-throughout-the-schema",level:4},{value:"Striking the right balance",id:"striking-the-right-balance",level:3},{value:"Models",id:"models",level:2},{value:"A warning for statically typed language users",id:"a-warning-for-statically-typed-language-users",level:4},{value:"Performant data loading",id:"performant-data-loading",level:2},{value:"Basic data loading",id:"basic-data-loading",level:4},{value:"Decoupled batching",id:"decoupled-batching",level:4},{value:"Caching",id:"caching",level:4}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"graphql-execution",children:"GraphQL Execution"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["This section talks about field resolvers, the ",(0,s.jsx)(n.code,{children:"Query"})," root type, and root-field resolvers\u2014",(0,s.jsxs)(n.em,{children:["which are ordinary field resolvers, but on the ",(0,s.jsx)(n.code,{children:"Query"})," root type"]}),". It is recommended to read at least sections 1 through 4 of ",(0,s.jsx)(n.a,{href:"https://graphql.org/learn/execution/",children:"this upstream guide"}),", prior to reading this here guide; or ",(0,s.jsx)(n.a,{href:"http://spec.graphql.org/October2021/#sec-Execution",children:"this section of the spec"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"The role of an execution engine in GraphQL is to convert between underlying services into GraphQL schema types for use in the front-end. We call this \u201cresolution\u201d."}),"\n",(0,s.jsx)(n.p,{children:"It does so by traversing the schema and resolving the fields requested in the query. The executor follows the structure of the query and passes the data returned by each field resolver to its child field resolvers. The executor ensures that only the fields that are requested by the client are resolved, and that the final result matches the shape of the query."}),"\n",(0,s.jsx)(n.h2,{id:"get-only-what-you-need",children:"Get only what you need"}),"\n",(0,s.jsxs)(n.p,{children:["A core part of GraphQL is that it allows clients to specify ",(0,s.jsx)(n.strong,{children:"the exact data"})," they need from the service. Unlike traditional RESTful APIs, where clients have to make multiple requests or receive more data than they need, GraphQL lets clients define the structure of the data they want and get ",(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.em,{children:"only"})," that data"]})," in a single request. Notably, this means that the client does not need to pay the price for any business logic required for fields that are not needed by the client. This makes GraphQL APIs more efficient, flexible, and scalable to clients that have such needs."]}),"\n",(0,s.jsx)(n.h2,{id:"resolution",children:"Resolution"}),"\n",(0,s.jsx)(n.p,{children:"To resolve the data of the GraphQL query, we need to define how each field in the schema is fetched from the data source. There are different ways to do this, depending on how we structure our code and how we optimize our performance. In this section, we will explore two variants of how to resolve the data of the query, starting with a naive version that simply returns the full entire response from the root-field, to one that has explicit field resolvers for each field with custom logic."}),"\n",(0,s.jsx)(n.p,{children:"But first, let's quickly cover how the executor will process your query. Let's consider the conversation list UI once more:"}),"\n",(0,s.jsxs)("table",{children:[(0,s.jsxs)("tr",{children:[(0,s.jsx)("th",{children:"Schema"}),(0,s.jsx)("th",{children:"Query"})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"type Query {\n  conversations: [Conversation]\n}\n\ntype Conversation {\n  title: String\n  lastMessage: String\n  receivedAt: String\n  participants: [Person]\n}\n\ntype Person {\n  avatarURL: String\n}\n"})})}),(0,s.jsx)("td",{children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"query {\n  conversations {\n    title\n    lastMessage\n    receivedAt\n    participants {\n      avatarUrl\n    }\n  }\n}\n"})})})]})]}),"\n",(0,s.jsx)(n.mermaid,{value:'graph TD\n  A[Query.conversations] --\x3e C["map(Array&lt;Conversation&gt;)"]\n  C --\x3e D[Conversation.title]\n  C --\x3e E[Conversation.lastMessage]\n  C --\x3e F[Conversation.receivedAt]\n  C --\x3e G[Conversation.participants]\n  G --\x3e H["map(Array&lt;Person&gt;)"]\n  H --\x3e I[Person.avatarURL]'}),"\n",(0,s.jsx)(n.p,{children:"In this case, when we query for conversations, GraphQL will:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Execute the resolver function for the ",(0,s.jsx)(n.code,{children:"Query.conversations"})," field, which returns an array of ",(0,s.jsx)(n.code,{children:"Conversation"})," objects."]}),"\n",(0,s.jsxs)(n.li,{children:["Then, for each individual ",(0,s.jsx)(n.code,{children:"Conversation"})," object in the array, GraphQL will execute the resolver function for the ",(0,s.jsx)(n.code,{children:"Conversation.title"}),", ",(0,s.jsx)(n.code,{children:"Conversation.lastMessage"}),", ",(0,s.jsx)(n.code,{children:"Conversation.receivedAt"}),", and ",(0,s.jsx)(n.code,{children:"Conversation.participants"})," fields."]}),"\n",(0,s.jsxs)(n.li,{children:["And finally, for each ",(0,s.jsx)(n.code,{children:"Person"})," object in the ",(0,s.jsx)(n.code,{children:"Conversation.participants"})," array, GraphQL will execute the resolver function for the ",(0,s.jsx)(n.code,{children:"Person.avatarURL"})," field."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"-greedy-resolution",children:"\ud83d\udc4e Greedy resolution"}),"\n",(0,s.jsxs)(n.p,{children:["The first resolution variant is the simplest one, where we just return the full response from the root-field. This means that we have a single resolver function for the ",(0,s.jsx)(n.code,{children:"conversations"})," field in the ",(0,s.jsx)(n.code,{children:"Query"})," type, and it returns an array of objects that match the shape of the ",(0,s.jsx)(n.code,{children:"Conversation"})," type. We don't need to define any other resolver functions for the nested fields, because GraphQL will ",(0,s.jsx)(n.a,{href:"#a-note-on-the-default-field-resolver",children:"by default"})," use the property values of the objects as the field values."]}),"\n",(0,s.jsx)(n.p,{children:"For example, if we have a data source that looks like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'function getMyConversations() {\n  return [\n    {\n      title: "Joshua and Daichi",\n      lastMessage: "You: Thank you!!",\n      receivedAt: "10:29 AM",\n      participants: [\n        {\n          avatarURL: "https://example.com/joshua.jpg",\n        },\n        {\n          avatarURL: "https://example.com/daichi.jpg",\n        },\n      ],\n    },\n    {\n      title: "Kadji Bell",\n      lastMessage: "You: I like the idea, let\u2019s pitch it!",\n      participants: [\n        {\n          avatarURL: "https://example.com/kadji.jpg",\n        },\n      ],\n      receivedAt: "10:02 AM",\n    },\n  ];\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Then our resolver function for the conversations field can simply return this array:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const resolvers = {\n  Query: {\n    conversations: () => getMyConversations(),\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This approach is easy to implement, and while it works for trivial queries and data sources, it has some drawbacks. For instance, it does not follow the core idea of GraphQL to ",(0,s.jsx)(n.a,{href:"#get-only-what-you-need",children:"get only what you need"}),", which leads to inefficient resource usage and performance issues. If we only want to get the ",(0,s.jsx)(n.code,{children:"title"})," and ",(0,s.jsx)(n.code,{children:"lastMessage"})," fields of each conversation, we still get the participants array with ",(0,s.jsx)(n.em,{children:"all"})," their ",(0,s.jsx)(n.code,{children:"avatarURLs"}),". This may seem innocuous in this contrived example, but imagine more complex data sources that require expensive logic to fulfil the participants data, and it can quickly add up."]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:["It is important to realize that what a field resolver returns does ",(0,s.jsx)(n.strong,{children:"not"})," equal what is returned to the client. Only fields selected in the request document are ever returned. If we had executed the following query, with the above resolver and rich data, the executor would still only ever send the ",(0,s.jsx)(n.code,{children:"title"})," values to the client."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"query {\n  conversations {\n    title\n  }\n}\n"})})]}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.h3,{id:"a-note-on-the-default-field-resolver",children:"A note on the default field resolver"}),(0,s.jsxs)(n.p,{children:["The default field resolver is a function that GraphQL uses to resolve the value of a field when no explicit resolver is provided. It works by looking up the property with the same name as the field on the parent object, or calling it as a function if it is one. For example, if we have a field called ",(0,s.jsx)(n.code,{children:"title"})," on a type called ",(0,s.jsx)(n.code,{children:"Conversation"}),", and no resolver for it, the default field resolver will try to return ",(0,s.jsx)(n.code,{children:"conversation.title"})," or call ",(0,s.jsx)(n.code,{children:"conversation.title()"})," if it exists."]}),(0,s.jsxs)(n.p,{children:["The following set of resolvers has the same result as the above, but ",(0,s.jsx)(n.em,{children:"without"})," relying on the default field resolver:"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const resolvers = {\n  Query: {\n    conversations: () => getMyConversations(),\n  },\n  Conversation: {\n    title: (conversation) => conversation.title,\n    lastMessage: (conversation) => conversation.lastMessage,\n    participants: (conversation) => conversation.participants,\n    receivedAt: (conversation) => conversation.receivedAt,\n  },\n  Person: {\n    avatarURL: (person) => person.avatarURL,\n  },\n};\n"})})]}),"\n",(0,s.jsx)(n.h3,{id:"-lazy-resolution",children:"\ud83d\udc4d Lazy resolution"}),"\n",(0,s.jsx)(n.p,{children:"The second resolution variant is more flexible and efficient than the first one, where we can have explicit field resolvers for each field in the schema. These field resolver functions allow us to define how to derive the field's value from the data source."}),"\n",(0,s.jsx)(n.p,{children:"For the following examples, consider this updated version of the conversation data source:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'function getMyConversations() {\n  const conversations = [\n    {\n      title: "Joshua and Daichi",\n      lastMessage: "You: Thank you!!",\n      receivedAt: "2023-04-15T17:29:00-08:00",\n      participantIDs: ["joshua", "daichi"],\n    },\n    {\n      title: "Kadji Bell",\n      lastMessage: "You: I like the idea, let\u2019s pitch it!",\n      participantIDs: ["kadji"],\n      receivedAt: "2023-04-15T17:02:00-08:00",\n    },\n  ];\n}\n\nconst resolvers = {\n  Query: {\n    conversations: () => getMyConversations(),\n  },\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Now consider that the ",(0,s.jsx)(n.code,{children:"receivedAt"})," value has not already been formatted for display in the data source, so instead we define a resolver function for this field that calculates its human-readable value from the raw format. Here is what that field resolver function could look like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const resolvers = {\n  Conversation: {\n    // Transform the `conversation.receivedAt` value to HH:MM AM/PM\n    receivedAt: (conversation) => {\n      const date = new Date(conversation.receivedAt);\n      return date.toLocaleTimeString("en-US", {\n        hour: "numeric",\n        hour12: true,\n        minute: "numeric",\n      });\n    },\n  },\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Similarly, the ",(0,s.jsx)(n.code,{children:"participants"})," value in the data source is more likely to be a list of person IDs, than it is to be a list of full-fledged person objects. In this scenario, we need to issue an extra call to the data source to get the actual data. It should go without saying that we absolutely want this to be done only when the client needs this data, and not fetch it greedily in the ",(0,s.jsx)(n.code,{children:"Query.conversations"})," root-field. Here is what that field resolver function could look like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const resolvers = {\n  Conversation: {\n    participants: (conversation) => getPeopleByIDs(conversation.participantIDs),\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Neat"})," \ud83d\udcf8"]}),"\n",(0,s.jsx)(n.h4,{id:"flexibility-for-different-needs",children:"Flexibility for different needs"}),"\n",(0,s.jsxs)(n.p,{children:["We can use this approach to optimize our performance by ",(0,s.jsx)(n.em,{children:"only"})," fetching or returning the data that we need for each field."]}),"\n",(0,s.jsxs)(n.p,{children:["Crucially, each field resolver only resolves exactly that which it is named after. For example, the ",(0,s.jsx)(n.code,{children:"Query.conversations"})," field returns a list of conversations from the data source. Similarly, if we only want to get the ",(0,s.jsx)(n.code,{children:"title"}),", ",(0,s.jsx)(n.code,{children:"lastMessage"}),", and ",(0,s.jsx)(n.code,{children:"receivedAt"})," fields of each conversation, we can avoid fetching or returning the participants array with all their ",(0,s.jsx)(n.code,{children:"avatarURL"}),"s."]}),"\n",(0,s.jsxs)(n.p,{children:["As you have learned in ",(0,s.jsx)(n.a,{href:"/graphitation/docs/learn-graphql/guides/the-design-of-graphql",children:"The Design of GraphQL"}),", this flexibility is at the heart of its design for composition of data requirements."]}),"\n",(0,s.jsx)(n.h4,{id:"consistency-throughout-the-schema",children:"Consistency throughout the schema"}),"\n",(0,s.jsxs)(n.p,{children:["Another benefit of using explicit field resolvers is that they can apply to any field that returns a ",(0,s.jsx)(n.code,{children:"Conversation"})," type, not just the top-level query. This means that you can reuse the same logic and transformations for different queries that also involve conversations. For instance, if you have a ",(0,s.jsx)(n.code,{children:"Person"})," type that has a ",(0,s.jsx)(n.code,{children:"conversations"})," field which returns all the conversations that a user participates in, you can use the same field resolvers as you would use for the ",(0,s.jsx)(n.code,{children:"Query.conversations"})," result. This way, you can avoid inconsistency in your API's results, while staying flexible in the queries it can execute."]}),"\n",(0,s.jsx)(n.p,{children:"In this case, only the following schema addition would be necessary to enable the above example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"type Person {\n  conversations: [Conversation]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Plus a field resolver function that does no work other than getting the conversations based on the appropriate context:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const resolvers = {\n  Person: {\n    conversations: (person) => getConversationsForPersonById(person.id),\n  },\n  Query: {\n    person: (_, args) => getPerson(args.id),\n  },\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"With that in place, you now have a schema that allows lazy resolution with a query like the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'query {\n  person(id: "daichi-fukuda") {\n    conversations {\n      title\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"striking-the-right-balance",children:"Striking the right balance"}),"\n",(0,s.jsxs)(n.p,{children:["Using a greedy GraphQL field resolver that does all its work in a single field resolver can ",(0,s.jsx)(n.em,{children:"seem"})," like a simple and straightforward way to implement a schema, but ",(0,s.jsx)(n.strong,{children:"it has significant drawbacks"})," in terms of resource usage and performance. It results in over-fetching data that is not needed by the client, and wasting time and memory on processing it."]}),"\n",(0,s.jsxs)(n.p,{children:["In conclusion, lazy field resolvers are ",(0,s.jsx)(n.strong,{children:"the recommended way"})," to implement any field that requires some custom logic. This can include scalar fields that need some derivation or transformation, as well as object fields that need to fetch associated data from other sources. Only for fields that are already present in the parent type\u2019s data source, and need no further processing, you can rely on the default field resolver\u2014this usually applies to scalar fields only."]}),"\n",(0,s.jsx)(n.h2,{id:"models",children:"Models"}),"\n",(0,s.jsx)(n.p,{children:"In GraphQL execution, there is no need for the GraphQL schema to match the data source. This means that we can design our schema based on the needs of our clients, rather than the structure of our database or API. In fact, very often we will want to hide values that the clients don't need at all or those values from which we derive the field's result."}),"\n",(0,s.jsxs)(n.p,{children:["For example, we might have a field in the schema called ",(0,s.jsx)(n.code,{children:"fullName"}),", which concatenates the ",(0,s.jsx)(n.code,{children:"firstName"})," and ",(0,s.jsx)(n.code,{children:"lastName"})," values from our model. We don't need to expose those fields in our schema if they are not useful to our clients, but the field resolver ",(0,s.jsx)(n.em,{children:"does"})," need access to the model data for it to be able to do its work."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"type Person {\n  fullName: String!\n\n  # NOTE: These fields do NOT exist in the schema.\n  # firstName: String!\n  # lastName: String!\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const resolvers = {\n  Person: {\n    fullName: (personDatabaseRow) =>\n      `${personDatabaseRow.firstName} ${personDatabaseRow.lastName}`,\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here, the ",(0,s.jsx)(n.code,{children:"personDatabaseRow"})," argument has all the underlying data we need. We call such a source, ",(0,s.jsx)(n.strong,{children:"the model"}),". ",(0,s.jsx)(n.em,{children:"Crucially"}),", the model type is ",(0,s.jsx)(n.strong,{children:"not"})," equal to the schema type. The model type is where the data comes ",(0,s.jsx)(n.em,{children:"from"}),", the schema type is what the resolver transforms the data ",(0,s.jsx)(n.em,{children:"to"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"A model can be a raw response from the data source, an intermediate representation, or a full fledged model class instance. A raw data source response is the most basic form of a model. It could be a row from a database table, a document from a database, or a JSON object from an API response."}),"\n",(0,s.jsxs)(n.p,{children:["An intermediate representation is a model that has some processing or transformation applied to it, perhaps ahead of time. For example, we might have a model that adds some computed properties during a background synchronization task. Note that this should ",(0,s.jsx)(n.strong,{children:"not"})," be transformation to full schema types."]}),"\n",(0,s.jsx)(n.p,{children:"A full fledged model class instance is a model that has methods and behaviors associated with it. For example, we might have a model class that implements validation rules, business logic, or custom methods for manipulating the data."}),"\n",(0,s.jsx)(n.p,{children:"Depending on our use case and preferences, we can choose any of these forms of models for our GraphQL execution. The only requirement is that our resolver functions can access the relevant properties of our models to return the correct values for our schema fields."}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["A good way to think about a model, is that whatever your data source returns ",(0,s.jsx)(n.strong,{children:"is your model"}),". In turn, these models are what the resolvers operate on to ",(0,s.jsx)(n.em,{children:"lazily"})," map underlying data to the public schema types."]})}),"\n",(0,s.jsxs)(n.admonition,{type:"caution",children:[(0,s.jsx)(n.h4,{id:"a-warning-for-statically-typed-language-users",children:"A warning for statically typed language users"}),(0,s.jsxs)(n.p,{children:["For type-safe field resolver implementations, you will typically want to generate typings to use in your resolvers. By default, codegen tools will typically emit typings that ",(0,s.jsx)(n.em,{children:"exactly"})," match the schema types. What this means is that your field resolver function will be required to return the data for child fields already transformed according to the schema. I.e. this forces you to apply ",(0,s.jsx)(n.a,{href:"#-greedy-resolution",children:"greedy resolution"}),". No bueno."]}),(0,s.jsx)(n.p,{children:"You will therefore absolutely want to pick a codegen tool that allows you to specify custom model typings for specific schema types. In the TypeScript space, such tools include:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Our own ",(0,s.jsx)(n.a,{href:"https://github.com/microsoft/graphitation/tree/main/packages/cli",children:"graphitation supermassive codegen"}),", which allows you to annotate your schema definition with the model typings to use."]}),"\n",(0,s.jsxs)(n.li,{children:["The popular ",(0,s.jsx)(n.a,{href:"https://the-guild.dev/graphql/codegen",children:"graphql-codegen"})," tool, which ",(0,s.jsx)(n.a,{href:"https://the-guild.dev/blog/better-type-safety-for-resolvers-with-graphql-codegen",children:"allows you to provide configuration"})," with schema type to model type mappings."]}),"\n"]})]}),"\n",(0,s.jsx)(n.h2,{id:"performant-data-loading",children:"Performant data loading"}),"\n",(0,s.jsx)(n.p,{children:"Integral to resolution of a graph of connected data, is that a query will end up containing many entities of the same kind, or perhaps even contain the same entity multiple times. For instance, for each conversation fetch all participants\u2014a classic N+1 problem."}),"\n",(0,s.jsx)(n.mermaid,{value:'graph LR\n  Q["Query.conversations"] --\x3e C1["Conversation.participants"]\n  Q --\x3e C2["Conversation.participants"]\n  subgraph Person Data Source\n    P1["Data Request 1"]\n    P2["Data Request 2"]\n    P3["Data Request 3"]\n  end\n  C1 --\x3e|"getPerson(\'joshua\')"| P1\n  C1 --\x3e|"getPerson(\'daichi\')"| P2\n  C2 --\x3e|"getPerson(\'kadji\')"| P3\n  P1 --\x3e U1["Person"]\n  P2 --\x3e U2["Person"]\n  P3 --\x3e U3["Person"]\n\nclassDef external fill:#f9f,stroke:#333;\nclass P1,P2,P3 external;'}),"\n",(0,s.jsxs)(n.p,{children:["These entities might be necessary for unrelated parts of the application, but still, for performance reasons we want to be able to batch that entity data loading. ",(0,s.jsx)(n.a,{href:"https://github.com/graphql/dataloader",children:"DataLoader"})," is a utility used to abstract request batching in GraphQL. It allows you to reason about a batch of requests, ",(0,s.jsx)(n.strong,{children:"without"})," needing to do so in the field resolver functions\u2014keeping them decoupled and without sacrificing the performance of batched data loading."]}),"\n",(0,s.jsx)(n.h4,{id:"basic-data-loading",children:"Basic data loading"}),"\n",(0,s.jsx)(n.p,{children:"Let\u2019s look at how DataLoader could be used for the participants in our chat-list example. First we define the DataLoader instance, like so:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const personLoader = new DataLoader(async (ids) => {\n  return getPeopleFromServiceByIDs(ids);\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"In essence, DataLoader takes a function that, given a set of IDs (or keys), will return a promise for a set of values."}),"\n",(0,s.jsx)(n.p,{children:"Then, for an individual conversation in the chat-list, we could use the DataLoader instance, like so:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const resolvers = {\n  Conversation: {\n    participants: async (conversation) => {\n      return personLoader.loadMany(conversation.participantIds);\n    },\n  },\n};\n"})}),"\n",(0,s.jsx)(n.mermaid,{value:'graph LR\n  Q["Query.conversations"] --\x3e C1["Conversation.participants"]\n  Q --\x3e C2["Conversation.participants"]\n  subgraph Person Data Source\n    P1["Data Request 1"]\n    P2["Data Request 2"]\n  end\n  C1 --\x3e|"personLoader.loadMany([\'joshua\', \'daichi\'])"| P1\n  C2 --\x3e|"personLoader.loadMany([\'kadji\'])"| P2\n  P1 --\x3e U1["Person"]\n  P1 --\x3e U2["Person"]\n  P2 --\x3e U3["Person"]\n\nclassDef external fill:#f9f,stroke:#333;\nclass P1,P2 external;'}),"\n",(0,s.jsxs)(n.p,{children:["This example isn't all that ground-breaking, as we already have the list of participant IDs for each conversation in the ",(0,s.jsx)(n.code,{children:"Conversation.participants"})," field resolver and can easily load them as a batch. (The only true benefit would be the caching of the people data, allowing for fast retrieval when resolving the same people again elsewhere in the query.)"]}),"\n",(0,s.jsx)(n.h4,{id:"decoupled-batching",children:"Decoupled batching"}),"\n",(0,s.jsxs)(n.p,{children:["It gets more interesting when we consider that the execution engine will resolve the participants for each conversation in the list ",(0,s.jsx)(n.strong,{children:"in parallel"}),". You could imagine it to work something like this pseudo code:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"Promise.all([\n  Conversation.participants({ ... }),\n  Conversation.participants({ ... })\n])\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now, when we pass a single ID (",(0,s.jsx)(n.em,{children:"or set"}),") to the DataLoader, we expect a single value (",(0,s.jsx)(n.em,{children:"or respective set"}),") to be returned; yet still batch them with the participants of ",(0,s.jsx)(n.em,{children:"all"})," other conversations."]}),"\n",(0,s.jsx)(n.mermaid,{value:'graph LR\n  Q["Query.conversations"] --\x3e C1["Conversation.participants"]\n  Q --\x3e C2["Conversation.participants"]\n  subgraph Person Data Source\n    P["Data Request 1"]\n  end\n  C1 --\x3e|"personLoader.loadMany([\'joshua\', \'daichi\'])"| P\n  C2 --\x3e|"personLoader.loadMany([\'kadji\'])"| P\n  P --\x3e U1["Person"]\n  P --\x3e U2["Person"]\n  P --\x3e U3["Person"]\n\nclassDef external fill:#f9f,stroke:#333;\nclass P external;'}),"\n",(0,s.jsx)(n.p,{children:"How this works is that all requests made of a DataLoader during a single tick of the JavaScript run-loop, will get batched together and passed to the batch function as a single list."}),"\n",(0,s.jsxs)(n.p,{children:["So, given our ",(0,s.jsx)(n.a,{href:"#%F0%9F%91%8E-greedy-resolution",children:"prior example data"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The execution engine would invoke the ",(0,s.jsx)(n.code,{children:"Conversation.participants"})," field resolver twice.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Once in a conversation with Joshua and Daichi: ",(0,s.jsx)(n.code,{children:'personLoader.loadMany(["joshua", "daichi"])'})]}),"\n",(0,s.jsxs)(n.li,{children:["And once in a conversation with Kadji: ",(0,s.jsx)(n.code,{children:'personLoader.loadMany(["kadji"])'})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["The DataLoader instance would then receive the following enqueued IDs as a ",(0,s.jsx)(n.em,{children:"single"})," list: ",(0,s.jsx)(n.code,{children:'["joshua", "daichi", "kadji"]'})]}),"\n",(0,s.jsxs)(n.li,{children:["And return the requested people to the 2 invocations of the ",(0,s.jsx)(n.code,{children:"Conversation.participants"})," field resolver for further transforming."]}),"\n",(0,s.jsxs)(n.li,{children:["Finally, the execution engine moves on to the next level of the query, by invoking the ",(0,s.jsx)(n.code,{children:"Person.avatarURL"})," field resolver for each of the 3 people."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"caching",children:"Caching"}),"\n",(0,s.jsx)(n.p,{children:"Additionally, DataLoader provides caching of entities during a single execution pass of an operation. This means that any participants present in all conversations, such as the authenticated user, will only get requested once. But also, if one of those people is requested again later on in the query, DataLoader will simply return it immediately."}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"A walkthrough of the DataLoader v1 source code by one of its authors, Lee Byron. While the source has changed since this video was made, it is still a good overview of the rationale of DataLoader and how it works."}),(0,s.jsx)("a",{href:"https://youtu.be/OQTnXNCDywA",target:"_blank",alt:"DataLoader Source Code Walkthrough",children:(0,s.jsx)("img",{src:"https://img.youtube.com/vi/OQTnXNCDywA/0.jpg"})})]})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);