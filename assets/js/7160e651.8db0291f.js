"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5874],{354:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/SmallChatList-48df39d6d39f34b20876ae5f9e68c64a.png"},4711:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"learn-graphql/guides/thinking-in-graphql","title":"Thinking in GraphQL","description":"How to think of the GraphQL abstraction layer and its purpose.","source":"@site/docs/learn-graphql/guides/thinking-in-graphql.md","sourceDirName":"learn-graphql/guides","slug":"/learn-graphql/guides/thinking-in-graphql","permalink":"/graphitation/docs/learn-graphql/guides/thinking-in-graphql","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/graphitation/tree/main/website/docs/learn-graphql/guides/thinking-in-graphql.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"id":"thinking-in-graphql","title":"Thinking in GraphQL","description":"How to think of the GraphQL abstraction layer and its purpose."},"sidebar":"tutorialSidebar","previous":{"title":"Intro","permalink":"/graphitation/docs/learn-graphql/intro"},"next":{"title":"The design of GraphQL","permalink":"/graphitation/docs/learn-graphql/guides/the-design-of-graphql"}}');var i=a(4848),r=a(8453);const s={sidebar_position:2,id:"thinking-in-graphql",title:"Thinking in GraphQL",description:"How to think of the GraphQL abstraction layer and its purpose."},o="Thinking in GraphQL",h={},l=[{value:"Abstractions for complex data-driven UI",id:"abstractions-for-complex-data-driven-ui",level:2},{value:"The \u201cgraph\u201d in GraphQL",id:"the-graph-in-graphql",level:2},{value:"Broad-Query",id:"broad-query",level:3},{value:"\ud83d\udc4d Schema design from front-end perspective",id:"-schema-design-from-front-end-perspective",level:3},{value:"\ud83d\udc4e Schema design from back-end perspective",id:"-schema-design-from-back-end-perspective",level:3},{value:"Generic <em>and</em> domain-specific",id:"generic-and-domain-specific",level:2},{value:"Query design",id:"query-design",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"thinking-in-graphql",children:"Thinking in GraphQL"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["This section shows GraphQL query and schema definition syntax. The first part of ",(0,i.jsx)(n.a,{href:"https://graphql.org/learn/schema/",children:"this upstream guide"})," will be useful to explain any bits that are not immediately clear."]})}),"\n",(0,i.jsxs)(n.p,{children:["As you will learn in ",(0,i.jsx)(n.a,{href:"/graphitation/docs/learn-graphql/guides/the-design-of-graphql",children:"the design of GraphQL"})," section, GraphQL was designed to allow components to express their own data requirements, and for those requirements to be composable into one or more larger UIs\u2014whilst not introducing any unnecessary coupling between the various components that make up the larger UI. Before making our way to that section, though, let\u2019s build a base-line understanding of how to think in GraphQL."]}),"\n",(0,i.jsx)(n.h2,{id:"abstractions-for-complex-data-driven-ui",children:"Abstractions for complex data-driven UI"}),"\n",(0,i.jsxs)(n.p,{children:["The GraphQL schema encodes the data requirements that the host is expected to be able to provide to the UI. At ",(0,i.jsx)(n.em,{children:"minimum"}),", this schema will be an intersection of all of the data requirements expressed by the UIs\u2014but it may be a superset because of past or future UI design iterations."]}),"\n",(0,i.jsxs)(n.p,{children:['It is very natural to initially view GraphQL from a "back-end" perspective, but this way of thinking will lead your schema design down the wrong path. Instead, you should view the schema as sitting in between your back-end and the front-end. Once you understand that this schema is ',(0,i.jsx)(n.em,{children:"in service of"})," the UI, it then logically follows that the schema exposes the domain data in ways that will very much resemble the way in which the data is presented in the UI."]}),"\n",(0,i.jsx)(n.p,{children:"For instance, a conversation list UI might care about presenting a list of conversations the user is in, with their last messages, associated participants, their avatars, and so on and so forth. It does not care about:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"the conversation metadata coming from a different back-end service than the participant metadata"}),"\n",(0,i.jsx)(n.li,{children:"that in some cases the back-end might have de-normalized [parts of] message metadata onto the conversation"}),"\n",(0,i.jsx)(n.li,{children:"that multiple back-end services might return different subsets for what is, semantically speaking, the same conversation object"}),"\n",(0,i.jsx)(n.li,{children:"or even the very act of fetching the data from the various back-end services"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"These are the types of implementation details that you want to abstract away from complex data-driven UI code, as that makes it easier to reason about and thus to maintain/optimize over time. Additionally, when thinking of complex applications, you will want to encapsulate business logic in a way that allows you to re-use it for other UIs, or perhaps even compute/transform the data in a background thread."}),"\n",(0,i.jsx)(n.p,{children:"All of these needs are met by a GraphQL schema that acts as the abstraction layer between your back-end and front-end."}),"\n",(0,i.jsx)(n.h2,{id:"the-graph-in-graphql",children:"The \u201cgraph\u201d in GraphQL"}),"\n",(0,i.jsx)(n.p,{children:"Another important UI consideration is rendering performance, or sometimes perceived performance. The former is achieved by having all data available that is necessary, for the initial state of the UI that the user should see, such that only a single render pass is required. (Sometimes this might mean that it can take a little while longer before rendering can start, but even then a single render pass can still provide an improvement to perceived performance.)"}),"\n",(0,i.jsxs)(n.p,{children:["Ideally all this data can be provided within a reasonable time-frame, but even then there are provisions in state-of-the-art GraphQL stacks that allow you to design a controlled loading experience using ",(0,i.jsx)(n.a,{href:"https://17.reactjs.org/docs/concurrent-mode-suspense.html#traditional-approaches-vs-suspense",children:"the \u201crender-as-you-fetch\u201d pattern"}),", as outlined in ",(0,i.jsx)(n.a,{href:"https://www.youtube.com/watch?v=Tl0S7QkxFE4",children:"this in-depth presentation"})," by a Facebook/Relay engineer."]}),"\n",(0,i.jsxs)(n.p,{children:["All in all, what this means is that the schema ",(0,i.jsx)(n.em,{children:"should"})," enable a piece of UI to fetch all data it needs, in a single request. This is where \u201cthe graph\u201d comes in, which means that the types that make up the schema are connected to each other in semantically meaningful ways and can be retrieved as a meaningful whole."]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.h3,{id:"broad-query",children:"Broad-Query"}),(0,i.jsxs)(n.p,{children:["This concept might seem foreign even to those already familiar with GraphQL. To solve this at Microsoft, we had to go as far as invent a new name for this very core concept: ",(0,i.jsx)(n.strong,{children:"Broad-Query"}),"."]}),(0,i.jsxs)(n.p,{children:["However, because in GraphQL ",(0,i.jsx)(n.em,{children:"all"})," queries are meant to be \u201cbroad\u201d, we will ",(0,i.jsx)(n.strong,{children:"not"})," keep repeating the \u201cBroad-Query\u201d term. After all, we want you to walk away from this guide as someone who truly understands GraphQL!"]})]}),"\n",(0,i.jsx)(n.h3,{id:"-schema-design-from-front-end-perspective",children:"\ud83d\udc4d Schema design from front-end perspective"}),"\n",(0,i.jsx)(n.p,{children:"When designing the schema in a vacuum, it might be hard to imagine what those connections should be. However, when considered from the perspective of a concrete piece of UI, and working your way backwards, it actually becomes a lot easier."}),"\n",(0,i.jsx)(n.p,{children:"Let's consider the conversation list UI example again:"}),"\n",(0,i.jsxs)("table",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Conversation list"}),(0,i.jsx)("th",{children:"UI components"}),(0,i.jsx)("th",{children:"GraphQL query"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("img",{src:a(354).A,border:"1"})}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"<ChatList>\n  <ChatListItem>\n    <Avatar />\n    <Title />\n    <LastMessage />\n    <Timestamp />\n  </ChatListItem>\n</ChatList>\n"})})}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"query {\n  conversations {\n    participants {\n      avatarUrl\n    }\n    title\n    lastMessage\n    receivedAt\n  }\n}\n"})})})]})]}),"\n",(0,i.jsx)(n.p,{children:"The UI components were probably very natural to imagine, right? Well, as you can see, the GraphQL query you would want to be able to write is an equally natural extrapolation."}),"\n",(0,i.jsx)(n.p,{children:"Finally, completing our top-down approach from UI design to GraphQL schema, the schema to power this would need to look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Query {\n  conversations: [Conversation]\n}\n\ntype Conversation {\n  participants: [Person]\n  title: String\n  lastMessage: String\n  receivedAt: String\n}\n\ntype Person {\n  avatarURL: String\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"-schema-design-from-back-end-perspective",children:"\ud83d\udc4e Schema design from back-end perspective"}),"\n",(0,i.jsx)(n.p,{children:"To contrast, let\u2019s look at a back-end perspective schema, and how it makes it impossible to fetch all data in a single request."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Query {\n  conversations: [Conversation]\n  person(id: ID): Person\n}\n\ntype Conversation {\n  participantIDs: [ID]\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this case, every root-field maps to a back-end service, and it of course does not return the full data for each related entity in its response payload, but rather contains foreign-keys to those related entities."}),"\n",(0,i.jsxs)(n.p,{children:["Because we can only get the IDs of participants in a conversation, rather than the actual ",(0,i.jsx)(n.code,{children:"Person"})," objects they refer to, we are being forced to make an additional request for ",(0,i.jsx)(n.em,{children:"each"})," participant in all of the conversations in the list. This is the N+1 problem and forces the UI to perform a waterfall of requests. This in turn will lead to a slow loading experience or staggered UI rendering."]}),"\n",(0,i.jsxs)(n.h2,{id:"generic-and-domain-specific",children:["Generic ",(0,i.jsx)(n.em,{children:"and"})," domain-specific"]}),"\n",(0,i.jsx)(n.p,{children:"The benefit of GraphQL is that it allows you to design your data schema in a way that reflects the domain of your application, rather than the structure of your database or the layout of your UI. This means that you can define types and fields that represent the entities and relationships in your domain, and expose them through a single endpoint that can be queried in a concise manner."}),"\n",(0,i.jsx)(n.p,{children:"However, this does not mean that you should create a schema that is tailored to a specific UI component or view. Doing so would limit the reusability and composability of your schema, and make it harder to evolve over time. Instead, you should aim to create a schema that is generic enough to support any UI requirement, but still specific enough to capture the domain logic and constraints."}),"\n",(0,i.jsx)(n.h3,{id:"query-design",children:"Query design"}),"\n",(0,i.jsxs)(n.p,{children:["For example, a \u201cperson\u201d whose name is rendered in one place of the UI, is the same \u201cperson\u201d whose email address is rendered elsewhere in the UI. Modeling this with a single GraphQL type (e.g. ",(0,i.jsx)(n.code,{children:"Person"}),"), regardless of what data source the data originates, allows you to have a single source of truth to consider."]}),"\n",(0,i.jsx)(n.p,{children:"For example, this React component and GraphQL fragment:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"function PersonAvatar(props) {\n  const person = useFragment(\n    graphql`\n      fragment PersonAvatarFragment on Person {\n        avatarUrl\n      }\n    `,\n    props.person,\n  );\n  return <img src={person.avatarUrl} />;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Can be used in ",(0,i.jsx)(n.em,{children:"any"}),' component hierarchy that embeds a "person". Such as a chat-list item:']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"function ChatListItem(props) {\n  const conversation = useFragment(\n    graphql`\n      fragment ChatListItemFragment on Conversation {\n        title\n        participants {\n          ...PersonAvatarFragment\n        }\n      }\n    `,\n    props.conversation,\n  );\n  return (\n    <li>\n      <h3>{conversation.title}</h3>\n      {conversation.participants.map(person => <PersonAvatar person={person}>)}\n    </li>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Or in a signed-in user control:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"function MeControl(props) {\n  const { me } = useFragment(\n    graphql`\n      fragment MeControlFragment on Query {\n        me {\n          displayName\n          ...PersonAvatarFragment\n        }\n      }\n    `,\n    props.query,\n  );\n  return (\n    <div>\n      <h3>Signed-in as {me.displayName}</h3>\n      <PersonAvatar person={me}>\n    </div>\n  );\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["But also crucial to a performant architecture when dealing with a complex data-driven application\u2014",(0,i.jsxs)(n.em,{children:["and as you will learn more about in ",(0,i.jsx)(n.a,{href:"/graphitation/docs/learn-graphql/guides/graphql-client",children:"the GraphQL client guide"})]}),"\u2014because now the person avatar is backed by a single source of truth, updating the ",(0,i.jsx)(n.code,{children:"Person"})," record in the GraphQL client's data-store with a new ",(0,i.jsx)(n.code,{children:"avatarUrl"})," allows the frameworks to know exactly all of the places in the UI where that data is needed and thus which components to re-render."]}),"\n",(0,i.jsxs)(n.p,{children:["I.e. the following pseudo-code is all it takes to automatically re-render the ",(0,i.jsx)(n.code,{children:"PersonAvatar"})," in the chat-list for each conversation the signed-in user participates in, as well as in the signed-in user control:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'client.update({\n  type: "Person",\n  id: "42",\n  avatarUrl: "http://example.com/new-me-who-dis",\n});\n'})}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsxs)(n.p,{children:["Once you start applying these patterns, you will notice how easy it becomes to re-use UI components and their fragments in various different component hierarchies, and also how easy it becomes to ",(0,i.jsx)(n.em,{children:"update"})," that data in a single place and have the change reflected everywhere in the UI."]}),"\n",(0,i.jsx)(n.p,{children:"This is where it all comes together and GraphQL truly shines \u2600\ufe0f"})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);